/*
*  Copyright (c) 2018, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
*
*  WSO2 Inc. licenses this file to you under the Apache License,
*  Version 2.0 (the "License"); you may not use this file except
*  in compliance with the License.
*  You may obtain a copy of the License at
*
*    http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/
package org.wso2.extension.siddhi.store.cassandra.util;

import org.wso2.extension.siddhi.store.cassandra.config.CassandraStoreConfig;
import org.wso2.extension.siddhi.store.cassandra.exception.CassandraTableException;
import org.wso2.siddhi.core.exception.CannotLoadConfigurationException;
import org.wso2.siddhi.core.util.config.ConfigReader;
import org.wso2.siddhi.query.api.annotation.Annotation;
import org.wso2.siddhi.query.api.definition.Attribute;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Unmarshaller;

import static org.wso2.extension.siddhi.store.cassandra.util.CassandraEventTableConstants.CONFIG_FILE;

/**
 * Class for holding various utility methods required by by the HBase table implementation.
 */
public class CassandraTableUtils {

    /**
     * Utility method which can be used to check if a given string instance is null or empty.
     *
     * @param field the string instance to be checked.
     * @return true if the field is null or empty.
     */
    public static boolean isEmpty(String field) {
        return (field == null || field.trim().length() == 0);
    }

    /**
     * This method is used to extract the primary keys from the String provided by the user.
     *
     * @param schema schema of the table defined by the user.
     * @param primaryKeys primary keys defined by the user
     * @return List of primary keys.
     */
    public static List<Attribute> initPrimaryKeys(List<Attribute> schema, Annotation primaryKeys) {
        List<String> keys = Arrays.asList(primaryKeys.getElements().get(0).getValue().split(","));
        List<Attribute> primaryKeyList = new ArrayList<>();
        schema.forEach(attribute -> keys.stream()
                .filter(key -> key.trim().equals(attribute.getName().trim()))
                .forEach(key -> primaryKeyList.add(attribute)));
        if (primaryKeyList.isEmpty()) {
            throw new CassandraTableException("Please enter a primary key within the defined table columns");
        }
        return primaryKeyList;
    }

    /**
     * This method converts Siddhi data types to Cassandra data types.
     * @param siddhiDataType siddhi data type of the attribute
     * @return returns the relevent String to he relevent cassandra data type
     */
    public static String convertToCassandraDataTypes(Attribute.Type siddhiDataType) {
        String cassandraDataType;
        switch (siddhiDataType) {
            case STRING:
                cassandraDataType = "text";
                break;
            case INT:
                cassandraDataType = "int";
                break;
            case LONG:
                cassandraDataType = "bigint";
                break;
            case DOUBLE:
                cassandraDataType = "double";
                break;
            case FLOAT:
                cassandraDataType = "float";
                break;
            case BOOL:
                cassandraDataType = "boolean";
                break;
            case OBJECT:
                cassandraDataType = "blob";
                break;
            default:
                cassandraDataType = "";
        }
        return cassandraDataType;
    }

    /**
     * This method will return a randomly generated UUID for the primary key.
     * @return returns the generated UUID
     */
    public static String generatePrimaryKeyValue() {
        return uuidGenerator();
    }

    /**
     * Primary key is generated by a this UUID generator.
     */
    private static String uuidGenerator() {
        return UUID.randomUUID().toString();
    }

    /**
     * This will read the cassandra-table-config.xml file which contains the syntax for Cassandra.
     * @throws CannotLoadConfigurationException exception throw when the configuration cannot be loaded
     */
    public CassandraStoreConfig readConfigFile(ConfigReader configReader) throws CannotLoadConfigurationException {
        InputStream inputStream = null;
        CassandraStoreConfig cassandraStoreConfig = new CassandraStoreConfig();
        try {
            JAXBContext ctx = JAXBContext.newInstance(CassandraStoreConfig.class);
            Unmarshaller unmarshaller = ctx.createUnmarshaller();
            ClassLoader classLoader = getClass().getClassLoader();
            inputStream = classLoader.getResourceAsStream(CONFIG_FILE);
            CassandraStoreConfig cassandraStoreXMLConfig = (CassandraStoreConfig) unmarshaller.unmarshal(inputStream);
            cassandraStoreConfig.setIndexQuery(configReader.
                    readConfig("indexQuery", cassandraStoreXMLConfig.getIndexQuery()));
            cassandraStoreConfig.setTableCreateQuery(configReader.
                    readConfig("tableCreateQuery", cassandraStoreXMLConfig.getTableCreateQuery()));
            cassandraStoreConfig.setTableValidityQuery(configReader.
                    readConfig("tableValidityQuery", cassandraStoreXMLConfig.getTableValidityQuery()));
            cassandraStoreConfig.setTableCheckQuery(configReader.
                    readConfig("tableCheckQuery", cassandraStoreXMLConfig.getTableCheckQuery()));
            cassandraStoreConfig.setRecordExistQuery(configReader.
                    readConfig("recordExistQuery", cassandraStoreXMLConfig.getRecordExistQuery()));
            cassandraStoreConfig.setRecordDeleteQuery(configReader.
                    readConfig("recordDeleteQuery", cassandraStoreXMLConfig.getRecordDeleteQuery()));
            cassandraStoreConfig.setRecordInsertQuery(configReader.
                    readConfig("recordInsertQuery", cassandraStoreXMLConfig.getRecordInsertQuery()));
            cassandraStoreConfig.setRecordSelectQuery(configReader.
                    readConfig("recordSelectQuery", cassandraStoreXMLConfig.getRecordSelectQuery()));
            cassandraStoreConfig.setRecordSelectNoKeyTable(configReader.
                    readConfig("recordSelectNoKeyTable", cassandraStoreXMLConfig.getRecordSelectNoKeyTable()));
            cassandraStoreConfig.setRecordUpdateQuery(configReader.
                    readConfig("recordUpdateQuery", cassandraStoreXMLConfig.getRecordUpdateQuery()));
        } catch (JAXBException e) {
            throw new CannotLoadConfigurationException(
                    "Error in processing Cassandra query configuration: " + e.getMessage(), e);
        } finally {
            if (inputStream != null) {
                try {
                    inputStream.close();
                } catch (IOException e) {
                    throw new CassandraTableException("Failed to close the input stream for" + CONFIG_FILE, e);
                }
            }
        }
        return cassandraStoreConfig;
    }
}
